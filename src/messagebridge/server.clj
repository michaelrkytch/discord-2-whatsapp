(ns messagebridge.server
  (:require [clojure.java.io]
            [clojure.tools.logging :as log]
            [clojure.tools.reader.edn :as edn]
            [com.stuartsierra.component :as component]
            [messagebridge.bot.forward-bot :as dcomm]
            [messagebridge.store :as store]
            [messagebridge.store.gcs-store :as gcs]
            [messagebridge.wacomms :as wacomm]
            [org.httpkit.server :as hk]
            [reitit.ring :as rr]
            [ring.util.response :as resp])
  (:import (java.nio.file Files Path StandardOpenOption)))


(defn web-handler
  "Handler is only responsible for serving up the QR code generated by Whatsapp Web at connection time.
  qr-file-path is the Path to the qr file"
  [^Path qr-file-path]
  (let [qr-handler (fn [_]
                     (-> qr-file-path
                         (Files/newInputStream (into-array [StandardOpenOption/READ]))
                         resp/response
                         (resp/content-type "image/jpeg")))]
    (rr/ring-handler
      (rr/router
        ["/qr/qr.jpg" {:get qr-handler}])
      (rr/create-default-handler))))

(defrecord WebServer [handler port                          ; parameters
                      http-server                           ; state
                      ]
  component/Lifecycle
  (start [this]
    (log/info "Starting web server on port " port)
    (assoc this :http-server (hk/run-server handler {:port                 port
                                                     :legacy-return-value? false})))
  (stop [this]
    (if http-server
      (do
        (hk/server-stop! http-server)
        (assoc this :http-server nil))
      this)))

(defn new-web-server [handler port]
  (map->WebServer {:handler handler
                   :port    port}))

(defn new-system
  "Build application system, including web server"
  [filesystem {:keys [port storage-dir] :as config}]
  (let [state-file (str storage-dir "/messagebridge.edn")
        state-file-path (gcs/get-path filesystem state-file)
        qr-file-path (gcs/get-path filesystem (str storage-dir "/qr.jpg"))
        web-handler (web-handler qr-file-path)]
    (component/system-map
      :store (store/new-store state-file-path)
      :wacomms (wacomm/new-wacomms qr-file-path)
      :bot (component/using
             (dcomm/new-bot config)
             [:wacomms :store])
      :web-server (new-web-server web-handler port))))

;; Handle to system for REPL interaction
(defonce system (atom nil))
(defn -main []
  (let [{:strs [PORT BUCKET_NAME STORAGE_DIR DISCORD_APP_ID DISCORD_APP_TOKEN]} (System/getenv)
        config {:port              (cond-> (or PORT "80") (string? PORT) Integer/parseInt)
                :storage-dir       (or STORAGE_DIR "/var/lib/messagebridge")
                ; TODO app id is only used to regsiter commands, so is not really needed for the bot runtime
                :discord-app-id    DISCORD_APP_ID
                :discord-app-token DISCORD_APP_TOKEN}
        ;; Assume GCS filesystem mapped to a bucket
        fs (gcs/get-bucket-fs BUCKET_NAME)
        sys (component/start (new-system fs config))
        ]
    (reset! system sys)
    ;; TODO figure out how to get this into component startup without circular dependency
    (wacomm/add-message-listener! (:wacomms sys) (partial dcomm/forward-wa-message (:bot sys)))
    ;; block until bot shuts down
    (dcomm/join (:bot sys))
    ))

(comment
  ;; commands for start up / shut down in repl using local filesystem for storage
  (def config (-> (clojure.java.io/resource "dev-config.edn")
                  slurp
                  edn/read-string
                  (assoc :port 8888, :storage-dir "/var/lib/messagebridge")))
  (reset! system (new-system (java.nio.file.FileSystems/getDefault) config))
  (swap! system component/start-system)
  ;; This is a separate step to avoid a circular dependency between wacomms and bot
  (wacomm/add-message-listener! (:wacomms @system) (partial dcomm/forward-wa-message (:bot @system)))
  (swap! system component/stop-system)
  )

